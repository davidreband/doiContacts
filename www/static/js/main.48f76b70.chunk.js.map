{"version":3,"sources":["components/ContactForm.js","components/Contact.js","components/ContactList.js","components/ContactsPage.js","components/WalletItem.js","components/WalletList.js","components/Wallets.js","App.js","serviceWorker.js","index.js"],"names":["ContactForm","input","addContact","onKeyPress","event","key","value","ref","node","onClick","Contact","contact","remove","id","email","readOnly","type","checked","confirmed","ContactList","contacts","contactNode","map","ID","ContactsPage","db","localStorageDB","localStorage","isNew","tableExists","createTable","insert","commit","state","data","queryAll","console","log","ourWallet","ourPrivateKey","privateKey","amountComplete","Number","bitcore","constants","VALIDATOR_FEE","btc","NETWORK_FEE","TRANSACTION_FEE","ourFrom","to","parts","split","domain","length","getPublicKey","then","validatorPublicKeyData","validatorPublicKey","PublicKey","validatorAddress","getAddressOfPublicKey","toString","createDoichainEntry","entry","ourAddress","publicKey","changeAddrress","getUTXOAndBalance","utxo","utxos","txSignedSerialized","createRawDoichainTX","nameId","nameValue","templateData","verifyLocalHash","getDataHash","encryptMessage","JSON","stringify","encryptedTemplateData","broadcastTransaction","txId","WalletItem","useState","balance","setBalance","Networks","defaultNetwork","get","addr","useEffect","a","response","balanceAllUTXOs","fetchData","WalletList","walletNode","item","Wallets","walletItemsChanged","setWalletItemsChanged","wallet","createWallet","url","getUrl","registerPublicKey","addWallet","App","TabPanel","props","children","index","other","Typography","component","role","hidden","aria-labelledby","Box","p","a11yProps","makeStyles","theme","root","flexGrow","backgroundColor","palette","background","paper","useStyles","React","setValue","AppBar","position","Tabs","onChange","newValue","aria-label","Tab","label","Boolean","window","location","hostname","match","startApp","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","cordova","addEventListener"],"mappings":"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","file":"static/js/main.48f76b70.chunk.js","sourcesContent":["import React from \"react\";\n\nconst ContactForm = ({addContact}) => {\n  let input;\n\n  const handleAddContact = () => {\n        addContact(input.value);\n        input.value = '';\n  }\n\n  const handleKeyPress = (event) => {\n        if(event.key === 'Enter'){\n            addContact(input.value)\n            input.value = '';\n        }\n  }\n\n  return (\n    <div>\n      <input onKeyPress={handleKeyPress} ref={node => {\n        input = node;\n      }} />\n      <button  onClick={handleAddContact}> + </button>\n    </div>\n  );\n};\n\nexport default ContactForm\n","import React from \"react\";\n\nconst Contact = ({contact, remove}) => {\n    return (<li onClick={() => { remove(contact.id)}}>{contact.email}\n    <input readOnly={true} type={\"checkbox\"}\n           checked={contact.confirmed}/></li> );\n}\n\nexport default Contact","import React from \"react\";\nimport Contact from \"./Contact\";\n\n\nconst ContactList = ({contacts, remove}) => {\n    const contactNode = contacts.map((contact) => {\n        return (<Contact contact={contact} key={contact.ID} remove={remove}/>)\n    });\n    return (<ul>{contactNode}</ul>);\n}\n\nexport default ContactList","import ContactForm from \"./ContactForm\";\nimport ContactList from \"./ContactList\";\nimport React from \"react\";\nimport localStorageDB from \"localstoragedb\";\nimport bitcore from \"bitcore-doichain\";\nimport getPublicKey from \"bitcore-doichain/lib/doichain/getPublicKey\";\nimport getDataHash from \"bitcore-doichain/lib/doichain/getDataHash\";\n\nconst ContactsPage = () => {\n\n    const  db = new localStorageDB(\"doiworks\", localStorage); //https://nadh.in/code/localstoragedb/\n    //db.drop(\"contacts\")\n    if( db.isNew() || !db.tableExists('contacts')) {\n        db.createTable(\"contacts\", [\"email\",\"confirmed\"]);\n        db.insert(\"contacts\", {email: \"nico@le-space.de\",confirmed:true})\n        db.commit();\n    }\n    const state = { data: db.queryAll(\"contacts\", {})};\n    const addContact = (email) => {\n        console.log('adding contacgt')\n        const contact = {text: email, confirmed:false}\n\n        //this.state.data.push(contact);\n        //this.setState({data: this.state.data});\n\n        const ourWallet =  db.queryAll(\"wallets\")[0]\n        const ourPrivateKey = ourWallet.privateKey\n\n        //console.log('using privkey',ourPrivateKey)\n        const amountComplete = Number(bitcore.constants.VALIDATOR_FEE.btc)+\n            Number(bitcore.constants.NETWORK_FEE.btc)+\n            Number(bitcore.constants.TRANSACTION_FEE.btc)\n\n        // const ourFrom = \"nico@le-space.de\"; //settings.from;\n        // const to = \"irina@le-space.de\"\n\n        //const ourFrom = \"alice-montevideo-140920191531@ci-doichain.org\"; //settings.from;\n        const ourFrom = \"alice-montevideo-230920191250@le-space.de\"; //settings.from; //coworking.yoga (delegated)\n        //const to = \"bob-montevideo-260920191905@doi.works\";\n        const to = email\n\n        const parts = to.split(\"@\"); //TODO check if this is an email\n        const domain = parts[parts.length-1];\n\n        getPublicKey(domain).then((validatorPublicKeyData) => {\n            console.log('validatorPublicKeyData',validatorPublicKeyData.key)\n            const validatorPublicKey = bitcore.PublicKey(validatorPublicKeyData.key)\n            const validatorAddress = bitcore.getAddressOfPublicKey(validatorPublicKey).toString()\n            bitcore.createDoichainEntry(ourPrivateKey, validatorPublicKey.toString(), ourFrom, to).then(function (entry) {\n                console.log(\"entry\",entry)\n                const ourAddress = bitcore.getAddressOfPublicKey(ourWallet.publicKey).toString()\n                const changeAddrress = ourAddress //just send change back to us for now - could be its better to generate a new address here\n\n                bitcore.getUTXOAndBalance(ourAddress, amountComplete).then(function (utxo) {\n\n                    if (utxo.utxos.length > 0) {\n                        console.log(`using utxos for ${amountComplete} DOI`, utxo)\n\n                        const txSignedSerialized = bitcore.createRawDoichainTX(\n                            entry.nameId,\n                            entry.nameValue,\n                            validatorAddress,\n                            changeAddrress,\n                            ourPrivateKey,\n                            utxo, //here's the necessary utxos and the balance and change included\n                            bitcore.constants.NETWORK_FEE.btc, //for storing this record\n                            bitcore.constants.VALIDATOR_FEE.btc //0.01 for DOI storage, 0.01 DOI for reward for validator, 0.01 revokation reserved\n                        )\n                        const subject = \"hi Irina\"\n                        const content = \"Dear Irina, please give me permission to write you an email.\\n${confirmation_url}\\n Yours\\nNico\"\n                        const contentType = \"text/plain\"\n                        const redirectUrl = \"http://www.le-space.de\"\n                        const returnPath = \"office@le-space.de\"\n\n                        const templateData = {\n                            \"recipient\": to,\n                            \"content\": content,\n                            \"redirect\": redirectUrl,\n                            \"subject\": subject,\n                            \"contentType\": (contentType || 'html'),\n                            \"returnPath\": returnPath\n                        }\n\n                        if (validatorPublicKeyData.type === 'default' || validatorPublicKeyData.type === 'delegated')  //we store a hash only(!) at the responsible validator - never on a fallback validator\n                            templateData.verifyLocalHash = getDataHash({data: (ourFrom + to)}); //verifyLocalHash = verifyLocalHash\n\n                        bitcore.encryptMessage(\n                            ourWallet.privateKey,\n                            validatorPublicKey.toString(),\n                            JSON.stringify(templateData)).then(function (encryptedTemplateData) {\n                            console.log(\"encryptedTemplateData\", encryptedTemplateData)\n\n                            bitcore.broadcastTransaction(\n                                entry.nameId,\n                                txSignedSerialized,\n                                encryptedTemplateData,\n                                validatorPublicKey.toString()).then(function (txId) {\n                                console.log(\"broadcasted doichain transaction to doichain node with txId\", txId)\n                            })\n                        })\n                    } else {\n                        console.log(\"insufficient funds \")\n                    }\n                })\n            })\n        }) //getPublicKey\n    }\n\n    const handleRemove = (id) => {\n        console.log('not removing',id)\n        return;\n\n        const remainder = this.state.data.filter((contact) => {\n            if(contact.ID !== id) return contact;\n            else return null\n        });\n\n        this.setState({data: remainder});\n    }\n\n    return(<div> <h1>Doi Contacts</h1>\n\n        <ContactForm addContact={addContact}/>\n        <ContactList\n            contacts={state.data}\n            remove={handleRemove}\n        /></div>)\n}\nexport default ContactsPage\n","import React, {setGlobal,useGlobal,useEffect,useRef,useState,setSate } from 'reactn';\nimport bitcore from \"bitcore-doichain\";\n\nconst WalletItem = ({publicKey}) => {\n    const [balance, setBalance] = useState(0);\n\n    bitcore.Networks.defaultNetwork =  bitcore.Networks.get('doichain-testnet')\n    const addr = bitcore.getAddressOfPublicKey(publicKey)\n        useEffect( () => {\n         async function fetchData(){\n             try{\n                 const response = await bitcore.getUTXOAndBalance(addr.toString())\n                // console.log(response)\n                 const balanceAllUTXOs = response.balanceAllUTXOs\n                 setBalance(balanceAllUTXOs)\n             }catch(Exception){\n                 console.log(\"error while fetching utxos from server\",publicKey)\n             }\n\n         }\n        fetchData();\n     })\n        //pubKey:{publicKey}\n    return (<li>pubKey:{publicKey} DoiCoin-Address: {addr.toString()} balance: {balance} DOI</li>);\n}\n\nexport default WalletItem\n","import React from \"react\";\nimport WalletItem from \"./WalletItem\";\nimport localStorageDB from \"localstoragedb\";\n\nconst WalletList = () => {\n    // TODO please update this list as soon as publicKey is created and update again as soon as publicKey got registered\n    const  db = new localStorageDB(\"doiworks\", localStorage); //https://nadh.in/code/localstoragedb/\n    if(db.tableExists(\"wallets\")) {\n        const wallets = db.queryAll(\"wallets\", {})\n        const walletNode = wallets.map((item) => {\n            return (<WalletItem key={item.ID} publicKey={item.publicKey}/>)\n        });\n        return (<ul>{walletNode}</ul>);\n    } return null\n\n}\n\nexport default WalletList","import React, { setGlobal, useEffect,useState } from 'reactn';\nimport bitcore from \"bitcore-doichain\";\nimport WalletList from \"./WalletList\";\n\nconst Wallets = () => {\n    const [walletItemsChanged, setWalletItemsChanged] = useState({walletItemsChanged:false});\n\n    const addWallet = () => {\n        const name = \"some name\"\n        const wallet = bitcore.createWallet(name)\n        const url = bitcore.getUrl()+\"/api/v1/importpubkey\"\n        bitcore.registerPublicKey(url, wallet.publicKey)\n        setWalletItemsChanged(true);\n    }\n\n    useEffect(() => {\n        setWalletItemsChanged(false)\n    },[walletItemsChanged])\n\n    return (\n        <div>\n            <h1>DoiCoin Wallets</h1>\n            <button onClick={() => {addWallet()}}>Add Wallet </button>\n            <WalletList/>\n        </div>\n    );\n}\n\nexport default Wallets\n","import React from 'react';\nimport * as PropTypes from \"prop-types\";\n\nimport './App.css';\nimport { makeStyles } from '@material-ui/core/styles';\n\nimport AppBar from '@material-ui/core/AppBar';\nimport ContactsPage from \"./components/ContactsPage\";\nimport Wallets from \"./components/Wallets\";\n\nimport Tabs from \"@material-ui/core/Tabs\";\nimport Tab from '@material-ui/core/Tab'\nimport Typography from \"@material-ui/core/Typography\";\nimport Box from \"@material-ui/core/Box\";\n\n\nconst App = () => {\n\n    function TabPanel(props) {\n        const { children, value, index, ...other } = props;\n\n        return (\n            <Typography\n                component=\"div\"\n                role=\"tabpanel\"\n                hidden={value !== index}\n                id={`simple-tabpanel-${index}`}\n                aria-labelledby={`simple-tab-${index}`}\n                {...other}\n            >\n                <Box p={3}>{children}</Box>\n            </Typography>\n        );\n    }\n\n    TabPanel.propTypes = {\n        children: PropTypes.node,\n        index: PropTypes.any.isRequired,\n        value: PropTypes.any.isRequired,\n    };\n    function a11yProps(index) {\n        return {\n            id: `simple-tab-${index}`,\n            'aria-controls': `simple-tabpanel-${index}`,\n        };\n    }\n\n    const useStyles = makeStyles(theme => ({\n        root: {\n            flexGrow: 1,\n            backgroundColor: theme.palette.background.paper,\n        },\n    }));\n\n    const classes = useStyles();\n    const [value, setValue] = React.useState(0);\n\n    const handleChange = (event, newValue) => {\n        setValue(newValue);\n    };\n  //const wallet = bitcore.createWallet(\"default\")\n  //const url = bitcore.getUrl()+\"/api/v1/importpubkey\"\n  //bitcore.registerPublicKey(url, wallet.publicKey)\n // console.log(wallet.publicKey.toString())\n    return (\n        <div>\n            <AppBar position=\"static\">\n                <Tabs value={value} onChange={handleChange} aria-label=\"simple tabs example\">\n                    <Tab label=\"Contacts\" {...a11yProps(0)} />\n                    <Tab label=\"Wallets\" {...a11yProps(1)} />\n                    <Tab label=\"Settings\" {...a11yProps(2)} />\n                </Tabs>\n            </AppBar>\n            <TabPanel value={value} index={0}>\n                <ContactsPage/>\n            </TabPanel>\n            <TabPanel value={value} index={1}>\n                <Wallets/>\n            </TabPanel>\n            <TabPanel value={value} index={2}>\n                Item Three\n            </TabPanel>\n        </div>\n    );\n}\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst startApp = () => {\n    ReactDOM.render(<App />,document.getElementById('root'));\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\nif(!window.cordova) {\n    startApp()\n} else {\n    document.addEventListener('deviceready', startApp, false)\n}\n"],"sourceRoot":""}